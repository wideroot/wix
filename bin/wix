#!/usr/bin/env ruby
require 'gli'
require 'fileutils'
require 'logger'
require 'wix'

include GLI::App

program_desc 'wix client'

version Wix::VERSION

subcommand_option_handling :normal
arguments :strict


desc "Show verbose output"
default_value false
switch [:v, :verbose], :negatable => false


desc "Create a empty local sub index"
command :init do |c|
  c.desc "Name of the index"
  c.flag [:name]
  c.default_value nil
  c.desc "User"
  c.flag [:user]
  c.default_value nil
  c.desc "The index (and files) will not be associate to the user"
  c.default_value false
  c.switch %i(anon), negatable: true
  c.desc "Other users will not see this index (they will see the files, but)"
  c.default_value false
  c.switch %i(hidden), negatable: true
  c.desc "Publish filenames"
  c.default_value true
  c.switch %i(filename), negatable: true
  c.desc "Publish paths"
  c.default_value true
  c.switch %i(path), negatable: true
  c.desc "Publish push time"
  c.default_value true
  c.switch %i(push-time), negatable: true
  c.desc "Publish commit time"
  c.default_value true
  c.switch %i(commit-time), negatable: true
  c.desc "Publish file time (mtime)"
  c.default_value true
  c.switch %i(file-time), negatable: true
  c.desc "Other users will see your commit messages"
  c.default_value true
  c.switch %i(message), negatable: true

  c.action do |global_options, options, args|
    pwd = Dir.pwd
    if init_wix(pwd)
      fail "A local sub index cannot be placed inside another local sub index `#{$wix_root}'."
    end
    fail "User cannot be none." if options['user'] == nil
    fail "Name cannot be none." if options['name'] == nil
    create_wix(pwd, options)
    puts "Created sub local index at `#{$wix_root}'."
  end
end


desc "Add entry to the index"
arg_name 'path', [:optional, :multiple]
command :add do |c|
  c.desc "Update the index just where it already has an entry matching <path>."
  c.default_value false
  c.switch [:u, :update], negatable: false
  c.desc "Update the index not only where the working tree has a file matching <path> but also where the index already has an entry."
  c.default_value false
  c.switch [:A, :all], negatable: false
end

desc "Remove entry from the index (not removing the files)"
arg_name 'path', [:optional, :multiple]
command :rm do |c|
  c.desc "Override the up-to-date check."
  c.default_value false
  c.switch [:f, :force], negatable: false
end

desc "Record changes to the index"
command :commit do |c|
  c.desc "Use the given <msg> as the commit message."
  c.default_value nil
  c.flag [:m, :message]
end

desc "Show the local sub index status"
command :push do |c|
end

desc "Update server local sub index"
arg_name 'path', [:optional, :multiple]
command :status do |c|
  c.action do |global_options, options, args|
    pwd = Dir.pwd
    init_wix!(pwd)
    args << $wix_root if args.empty?
    base = Pathname.new($wix_root)
    stage = stage_commit
    args.each do |path|
      p = Pathname.new(File.absolute_path(path))
      if p.relative_path_from(base).to_s.start_with?('..')
        fail "`#{path}' is outside local sub index `#{$wix_root}'"
      end
    end
    staged = {}
    not_staged = {}
    untracked = {}
    args.each do |path|
      status(path, base, stage, staged, not_staged, untracked)
    end
    puts "Files to be committed:"
    if !staged.empty?
      puts ""
      staged.each do |path, state|
        state_msg = if state == 'r'
          'deleted: '
        elsif state =='a'
          'added:   '
        else
          fail "Invalid state `#{state}' for staged file."
        end
        puts "    #{state_msg} #{path}"
      end
      puts ""
    end
    puts "Files not staged for commit:"
    if !not_staged.empty?
      puts ""
      not_staged.each do |path, state|
        state_msg = if state == 'r'
          'deleted: '
        elsif state =='m'
          'modified:'
        else
          fail "Invalid state `#{state}' for staged file."
        end
        puts "    #{state_msg} #{path}"
      end
      puts ""
    end
    puts "Untracked files:"
    if !untracked.empty?
      puts ""
                #'modified:'
      untracked.each do |path, state|
        puts "    #{path}"
      end
      puts ""
    end
  end
end


pre do |global,command,options,args|
  $verbose_level = global[:verbose] ? 1 : 0
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
