#!/usr/bin/env ruby
require 'gli'
require 'fileutils'
require 'logger'
require 'wix'

include GLI::App

program_desc 'wix client'

version Wix::VERSION

subcommand_option_handling :normal
arguments :strict


desc "Show verbose output"
default_value false
switch [:v, :verbose], :negatable => false


desc "Create a empty local sub index"
command :init do |c|
  c.desc "Name of the index"
  c.flag [:name]
  c.default_value nil
  c.desc "User"
  c.flag [:user]
  c.default_value nil
  c.desc "The index (and files) will not be associate to the user"
  c.default_value false
  c.switch %i(anon), negatable: true
  c.desc "Other users will not see this index (they will see the files, but)"
  c.default_value false
  c.switch %i(hidden), negatable: true
  c.desc "Publish filenames"
  c.default_value true
  c.switch %i(filename), negatable: true
  c.desc "Publish paths"
  c.default_value true
  c.switch %i(path), negatable: true
  c.desc "Publish push time"
  c.default_value true
  c.switch %i(push-time), negatable: true
  c.desc "Publish commit time"
  c.default_value true
  c.switch %i(commit-time), negatable: true
  c.desc "Publish file time (mtime)"
  c.default_value true
  c.switch %i(file-time), negatable: true
  c.desc "Other users will see your commit messages"
  c.default_value true
  c.switch %i(message), negatable: true

  c.action do |global_options, options, args|
    pwd = Dir.pwd
    if init_wix(pwd)
      fail "A local sub index cannot be placed inside another local sub index `#{$wix_root}'."
    end
    fail "User cannot be none." if options['user'] == nil
    fail "Name cannot be none." if options['name'] == nil
    create_wix(pwd, options)
    puts "Created sub local index at `#{$wix_root}'."
  end
end


def arg_command args, add_root_if_empty = false, exists = false
  pwd = Dir.pwd
  init_wix!(pwd)
  args << $wix_root if args.empty? && add_root_if_empty
  base = Pathname.new($wix_root)
  paths = args.map do |path|
    p = Pathname.new(File.absolute_path(path))
    if p.relative_path_from(base).to_s.start_with?('..')
      fail "`#{path}' is outside local sub index `#{$wix_root}'"
    end
    if exists
      if !File.file?(path) && !Dir.exists?(path)
        fail "path `#{path}' did not match any file"
      end
    end
    p
  end
  [base, paths]
end

desc "Add entry to the index"
arg_name 'path', [:optional, :multiple]
command :add do |c|
  c.desc "Update the index just where it already has an entry matching <path>."
  c.default_value false
  c.switch [:u, :update], negatable: false
  c.desc "Update the index not only where the working tree has a file matching <path> but also where the index already has an entry."
  c.default_value false
  c.switch [:A, :all]
  c.desc "Update the index by adding new files that are unknown to the index and files modified in the local sub index, but ignore files that have been removed from the local sub index."
  c.default_value false
  c.switch %i(no-all)
  c.action do |global_options, options, args|
    if options['all'] && options['update']
      fail "-A and -u are mutually incompatible"
    end
    if !options['all'] || options['update']
      options['all'] = true
    end
    base, paths = arg_command(args, exist: true)
    if paths.empty?
      if options['updated'] || options['all']
        paths << Pathname.new(File.absolute_path(path))
      else
        puts "Nothing specified, nothing added."
      end
    end
    stage = stage_commit
    paths.each do |path|
      add(path, base, stage, options)
    end
  end
end

desc "Remove entry from the index (not removing the files)"
arg_name 'path', [:optional, :multiple]
command :rm do |c|
  c.desc "Override the up-to-date check."
  c.default_value false
  c.switch [:f, :force], negatable: false
end

desc "Update server local sub index"
arg_name 'path', [:optional, :multiple]
command :status do |c|
  c.action do |global_options, options, args|
    base, paths = arg_command(args, add_root_if_empty: true)
    stage = stage_commit
    staged = {}
    not_staged = {}
    untracked = {}
    paths.each do |path|
      status(path, base, stage, staged, not_staged, untracked)
    end
    puts "Files to be committed:"
    if !staged.empty?
      puts ""
      staged.each do |path, action|
        action_msg = if action == 'r'
          'deleted: '
        elsif action =='a'
          'added:   '
        else
          fail "Invalid action `#{action}' for staged file."
        end
        puts "    #{action_msg} #{path}"
      end
      puts ""
    end
    puts "Files not staged for commit:"
    if !not_staged.empty?
      puts ""
      not_staged.each do |path, action|
        action_msg = if action == 'r'
          'deleted: '
        elsif action =='m'
          'modified:'
        else
          fail "Invalid action `#{action}' for staged file."
        end
        puts "    #{action_msg} #{path}"
      end
      puts ""
    end
    puts "Untracked files:"
    if !untracked.empty?
      puts ""
                #'modified:'
      untracked.each do |path, action|
        puts "    #{path}"
      end
      puts ""
    end
  end
end


desc "Record changes to the index"
command :commit do |c|
  c.desc "Use the given <msg> as the commit message."
  c.default_value nil
  c.flag [:m, :message]
end

desc "Show the local sub index status"
command :push do |c|
end


pre do |global,command,options,args|
  $verbose_level = global[:verbose] ? 1 : 0
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
